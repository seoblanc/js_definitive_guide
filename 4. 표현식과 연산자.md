# 4. 표현식과 연산자

표현식이란 어떤 값으로 평가 되는 구절이다.

상수, 변수 또한 표현식이며 여러 연산자를 조합하여 새 값으로 평가 할 수 있다.

### 기본 표현식

- 상수, 리터럴 값, 일부 키워드, 변수 참조

### 객체와 배열 초기화 표현식

- 초기화 표현식 == (객체, 배열)리터럴
  - 초기화 표현식은 프로퍼티와 요소 값을 지정하는 다양한 하위 표현식으로 구성된다.

```jsx
// 배열 초기화 표현식
[]
[1+2, 3+4]
let matrix = [[1,2,3], [4,5,6], [7,8,9]]
let sparseArray = [1,,,,,5]

// 객체
let p = {x:2.3, y:4,5}
let q = {}
q.x = 2.3
q.y = -1.2
p.x === q.x // true
p === q // false
```

### 함수 정의 표현식

- 함수의 정의, 값은 함수 이며, 함수 리터럴 이라고도 한다.

### 프로퍼티 접근 표현식

- 객체 프로퍼티나 배열 요소의 값으로 평가된다.
  - expression . identifier
  - expression . [ expression ]
- 프로퍼티명에 스페이스, 구두점, 숫자(배열), 혹은 계산하여 얻을 경우 대괄호 를 사용한다.
- 조건부 프로퍼티 접근(ES2020)

  - 프로퍼티를 가질 수 없는 null, undefined 제어.
  - expression ?. identifier
  - expression ?. [ expression ]
  - 왼쪽 expression이 null이나 undefined 로 평가될 때 TypeError를 방지하고 undefined를 반환한다.

  ```jsx
  let a = { b: null };
  a.b?.c.d; // undefined

  // null, undefined가 아닌 값 평가를 위해서는 하위에서 조건부 프로퍼티 접근이 필요하다.
  a = { b: {} };
  a.b?.c?.d; // undefined

  let arr; // undefined
  let index = 0;
  try {
    arr[index++]; // TypeError
  } catch (e) {
    index; // 1
  }

  arr?.[index++]; // undefined, arr이 정의되지 않음.
  index; // 1, ?.는 단축 평가이므로 index는 증가하지 않음.
  arr[index++]; // TypeError, 정의되지 않은 것에서 인덱스를 찾을 수 없음.
  ```

### 호출 표현식

- 함수나 메서드를 호출(실행)하는 문법
- 호출 표현식 맨 앞에 있는 표현식이 프로퍼티 접근 표현식이라면 메서드 호출이라고 하며, 메서드 호출에서 프로퍼티 접근 대상인 객체 또는 배열은 함수 바디가 실행되는 동안 this 키워드의 값이 된다.
- 조건부 호출(ES2020)

  - ?.() 호출 문법으로 왼쪽의 표현식이 null, undefined인 경우 undefined로 평가한다.

  ```jsx
  function square(x, log) {
    // 두번째 인자는 선택사항인 함수
    log?.(x); // 전달 받은 함수가 있다면 호출
    return x * x;
  }
  // 실제로 전달 받은 값이 함수인지는 체크하지 않는다. square(2, 2) => 에러 발생

  // 조건부 프로퍼티 접근과 메서드 호출을 헷갈리지 말자.
  o.m(); // 일반적인 프로퍼티 접근, 일반적인 호출
  o?.m(); // 조건부 프로퍼티 접근, 일반적인 호출
  o.m?.(); // 일반적인 프로퍼티 접근, 조건부 호출
  ```

### 객체 생성 표현식

- new 키워드를 사용하여 객체를 생성하고 생성자 함수를 호출해 객체 프로퍼티를 초기화 한다.

```jsx
new Object();
new Object(); // 전달할 인자가 없다면 생략 가능
new Date(); // 전달할 인자가 없다면 생략 가능
new Point(2, 3);
```

### 연산자

- 산술 표현식, 비교 표현식, 논리 표현식, 할당 표현식 등에 사용되며, 각 연산자의 우선순위에 주의하며 사용해야 한다.
- 연산자 우선순위

```jsx
w = x + y * z; // 곱셈연산자의 우선순위가 높음
w = (x + y) * z; // 괄호로 연산자 우선순위를 덮어씀
```

### 산술 표현식

- \*_(지수), _, /, %, +, -
- 덧셈 연산자는 피연산자 중 하나라도 문자열이 존재한다면 모든 피연산자를 문자열로 변환하여 병합한다.
- 나머지 연산자는 피연산자를 평가해서 필요하다면 숫자로 변환하며, 숫자로 변환할 수 없다면 NaN이 된다.

```jsx
1 + 2; // 3
"1" + "2"; // "12"
"1" + 2; // "12"
1 + {}; // "1[object Object]"
true + true; // 2, 불 값을 숫자로 변환
2 + null; // 2, null을 0으로 변환
2 + undefined; // NaN, undefined 를 NaN으로 변환

// + 연산자의 결합성에 의해 1,2를 먼저 더하고 문자열을 병합한다.
1 + 2 + " blind mice"; // "3 blind mice"
1 + (2 + " blind mice"); // "12 blind mice"
```

### 단항 산술 연산자

- +, -, ++, —
- ++(증가), —(감소) 연산자의 반환 값은 피연산자와의 위치 관계에 따라 달라진다.

```jsx
let i = 1,
  j = ++i; // i,j => 2
let n = 1,
  m = n++; // n => 2, m => 1
```

### 비트 연산자

- AND(&) : 둘 다 1인 경우 1
- OR(|) : 한쪽이라도 1인 경우 1
- XOR(^) : 한쪽에만 1인 경우 1
- NOT(~) : 단항 연산자, 비트 뒤집기
- 왼쪽 시프트 (<<) : 첫 번째 피연산자의 비트를 모두 두 번째 피연산자 값만큼 왼쪽으로 이동
- 부호 붙은 오른쪽 시프트(>>):첫 번째 피연산자의 모든 비트를 두 번째 피연산자의 숫자 만큼 오른쪽으로 이동
- 0으로 채우는 오른쪽 시프트(>>>)
  : 첫 번째 피연산자의 부호와 관계없이 항상 0으로 채운다.

### 관계 표현식

- 일치와 불일치 연산자
  - 동등 연산자(==): 값 비교시 타입 변환을 허용하므로 두 피연산자가 ‘같다고 볼 수 있는지' 체크한다
  - 일치 연산자(===): 두 피연산자가 ‘완전히' 일치하는지 체크한다.
  - !=, !== 를 사용하여 ‘동등하다고 볼 수 없는지’, ‘일치하지 않는지' 체크할 수 있다.
- 일치
  - 두 값이 다른 타입이면 같은 값이 아니다.
  - 두 값이 모두 null 이거나 모두 undefined면 같은 값이다.
  - 두 값이 모두 불 값 true거나, false면 같은 값이다.
  - 두 값 중 하나라도 NaN이면 같은 값이 아니다. NaN은 자기 자신을 포함해 어느 값과도 같지 않다.
- 동등성과 타입 변환
  - 하나가 null이고 다른 하나가 undefined면 같은 값이다.
  - 하나가 숫자이고, 다른 하나가 문자열이라면 문자열을 숫자로 변환하고 비교한다.
  - 값 중 하나가 true면 1로(false면 0으로) 변환한 후 다시 비교한다.
    ```jsx
    “1” == true // true
    ```
  - 값 중 하나가 객체이고 다른 값이 숫자나 문자열이면 자바스크립트 객체 변환 알고리즘에 따라 객체를 기본값으로 변환한 후 비교한다. valueOf() 또는 toString()메서드를 통해 기본값으로 변환된다.
- 비교 연산자
  - 미만(<), 초과(>), 이하(≤), 이상(≥)
- in 연산자
  - 왼쪽 피연산자가 오른쪽 객체의 프로퍼티 이름(문자열, 심벌 등)일 경우 true를 반환한다.
- instanceof
  - 왼쪽에 있는 객체가 오른쪽에 있는 클래스의 인스턴스 라면 true
  - 자바스크립트 클래스는 초기화 기능이 있는 생성자 함수를 통해 정의되는 객체 이므로 오른쪽 피연산자는 함수여야 한다.
  ```jsx
  let d = new Date();
  d instanceof Date;
  d instanceof Object;
  d instanceof Number; // false
  let a = [1, 2, 3];
  a instanceof Array;
  a instanceof Object;
  a instanceof RegExp; // false
  ```

### 논리 표현식

- 불 AND (&&) : 두 피연산자가 모두 true인 경우 true 반환
  - 오른쪽 피연산자에 왼쪽의 피연산자의 값의 결과에 따라 조건부 실행하는데 사용하기도 한다.
  ```jsx
  a === b && stop();
  ```
- 불 OR (||) : 두 피연산자 중 하나라도 true라면 true 반환
  - 왼쪽 피연산자가 true라면 오른쪽 피연산자는 평가하지 않는다.
- 불 NOT (!) : 단일한 피연산자 앞에 사용하며 중첩사용(!!)으로 그와 동등한 불 값으로 변환할 수 있다.

### 할당 표현식

- = 연산자를 사용해 변수나 프로퍼티에 값을 할당한다.
- +=, -=, \*\*= 등 연산자와 결합하여 할당과 연산을 동시에 하는 단축 표현을 지원한다.

### 기타 연산자

- 조건 연산자 (삼항 연산자, ?:)
- null 병합 연산자 (??) : 왼쪽 피연산자가 null 또는 undefined 라면 우측 피연산자를 반환한다.
  ```jsx
  let options = { timeout: 0, titile: "", verbose: false, n: null };
  options.timeout ?? 1000; // 0
  options.title ?? "untitled"; // '' : 객체에 정의된 대로
  options.title || "untitled"; // 'untitled'
  options.verbose ?? true; // false : 객체에 정의된 대로
  options.verbose || true; // true
  options.n ?? 10; // 10
  ```
- typeof 연산자 : 피연산자의 타입을 문자열로 반환한다.
- delete 연산자 : 객체 프로퍼티나 배열 요소를 삭제하는 단항 연산자
- await 연산자 : 비동기 연산을 나타내는 프라미스 객체를 피연산자로 예상하고 동작한다. async 함수 안에서 동작한다.
